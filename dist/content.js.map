{"version":3,"file":"content.js","mappings":";;AAAA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://rogue-cluster/webpack/bootstrap","webpack://rogue-cluster/webpack/runtime/make namespace object","webpack://rogue-cluster/./src/content.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","console.log(\"LinkedIn Face Tracker: Content script loaded (v2.0.0 Sandbox).\");\n\nfunction createTrackerIframe() {\n    if (document.getElementById('face-tracker-iframe')) return;\n\n    const iframe = document.createElement('iframe');\n    iframe.id = 'face-tracker-iframe';\n    iframe.src = chrome.runtime.getURL('sandbox.html');\n    iframe.allow = \"camera; microphone\";\n\n    // Style the iframe to act as the floating window\n    Object.assign(iframe.style, {\n        position: 'fixed',\n        bottom: '20px',\n        right: '20px',\n        width: '240px',\n        height: '420px',\n        border: 'none',\n        zIndex: '2147483647',\n        backgroundColor: 'transparent'\n    });\n\n    document.body.appendChild(iframe);\n    console.log(\"LinkedIn Face Tracker: Iframe injected.\");\n}\n\n// Listen for messages from the sandbox\nwindow.addEventListener('message', (event) => {\n    if (event.data && event.data.type === 'EXPRESSION_DETECTED') {\n        const { expression, emoji } = event.data;\n\n        // Skip neutral\n        if (emoji !== 'ðŸ˜') {\n            injectEmojiIntoActivePost(emoji);\n        }\n    } else if (event.data && event.data.type === 'SANDBOX_READY') {\n        // When sandbox boots, send it the current dev panel visibility preference\n        chrome.storage.local.get(['showDevPanel']).then((result) => {\n            const isVisible = result.showDevPanel !== undefined ? result.showDevPanel : true;\n            event.source.postMessage({ type: 'TOGGLE_DEV_PANEL', isVisible }, '*');\n        });\n    }\n});\n\n// Listen for live toggle changes from the popup\nchrome.storage.onChanged.addListener((changes, namespace) => {\n    if (namespace === 'local' && changes.showDevPanel) {\n        const iframe = document.getElementById('face-tracker-iframe');\n        if (iframe && iframe.contentWindow) {\n            iframe.contentWindow.postMessage({ type: 'TOGGLE_DEV_PANEL', isVisible: changes.showDevPanel.newValue }, '*');\n        }\n    }\n});\n\nlet activePost = null;\nlet isPaused = false;\nlet lastReactedPost = null;\n\n// Track the most central post on scroll\nfunction updateActivePost() {\n    // Select the second parent div above the feed-shared-update-v2 element\n    const posts = document.querySelectorAll('.scaffold-finite-scroll__content div:has(> div > .feed-shared-update-v2)');\n\n    if (posts.length === 0) return;\n\n    const viewportCenter = window.innerHeight / 2;\n    let closestPost = null;\n    let minDistance = Infinity;\n\n    posts.forEach(post => {\n        const rect = post.getBoundingClientRect();\n\n        // Calculate the center of the post relative to viewport\n        const postCenter = rect.top + rect.height / 2;\n        const distance = Math.abs(viewportCenter - postCenter);\n\n        if (distance < minDistance) {\n            minDistance = distance;\n            closestPost = post;\n        }\n    });\n\n    // Update highlights\n    if (closestPost !== activePost) {\n        if (activePost) {\n            activePost.style.boxShadow = '';\n            activePost.style.borderRadius = '';\n            activePost.style.transition = '';\n        }\n\n        activePost = closestPost;\n\n        if (activePost) {\n            activePost.style.transition = 'box-shadow 0.3s ease, transform 0.3s ease';\n            // Use a clean elevation shadow to make the card \"float\" above the feed\n            // This is instantly noticeable but retains the native, colorless UI feel\n            activePost.style.boxShadow = '0 12px 32px rgba(0, 0, 0, 0.2), 0 4px 12px rgba(0, 0, 0, 0.1)';\n            activePost.style.borderRadius = '8px';\n        }\n    }\n}\n\nlet scrollTimeout;\nwindow.addEventListener('scroll', () => {\n    if (isPaused) return; // Pause tracking during injections to avoid highlight jumps\n    window.clearTimeout(scrollTimeout);\n    scrollTimeout = setTimeout(updateActivePost, 100); // 100ms debounce\n}, { passive: true });\n\nfunction injectEmojiIntoActivePost(emoji) {\n    if (!activePost) {\n        console.warn(\"LinkedIn Face Tracker: No active post selected.\");\n        return;\n    }\n\n    if (activePost === lastReactedPost) {\n        console.log(\"LinkedIn Face Tracker: Already reacted to current active post. Ignoring.\");\n        return;\n    }\n\n    // Mark this post as the last reacted one\n    lastReactedPost = activePost;\n\n    // Pause scroll highlighting for 3 seconds to avoid jumping when comment UI expands/scrolls\n    isPaused = true;\n    setTimeout(() => {\n        isPaused = false;\n    }, 3000);\n\n    // Attempt to find the comment box in the active post\n    let commentBox = activePost.querySelector('.ql-editor[role=\"textbox\"]');\n\n    if (!commentBox) {\n        // Comment box might be closed. Try to click the \"Comment\" button first.\n        const commentBtns = Array.from(activePost.querySelectorAll('button')).filter(btn => {\n            const label = btn.getAttribute('aria-label');\n            return label && (label.toLowerCase().includes('comment') || label.toLowerCase().includes('reply'));\n        });\n\n        if (commentBtns.length > 0) {\n            commentBtns[0].click();\n            // Wait for React to render the comment box, then inject\n            setTimeout(() => {\n                commentBox = activePost.querySelector('.ql-editor[role=\"textbox\"]');\n                if (commentBox) {\n                    insertTextIntoEditor(commentBox, emoji);\n                } else {\n                    console.warn(\"LinkedIn Face Tracker: Could not find comment box even after clicking comment button.\");\n                }\n            }, 400); // 400ms delay for UI render\n        } else {\n            console.warn(\"LinkedIn Face Tracker: Could not find a Comment button to open.\");\n        }\n    } else {\n        insertTextIntoEditor(commentBox, emoji);\n    }\n}\n\nfunction insertTextIntoEditor(editor, text) {\n    // Focus the editor so execCommand targets the correct element,\n    // but use preventScroll so the browser doesn't snap-scroll and ruin the activePost highlighting.\n    editor.focus({ preventScroll: true });\n\n    // Most reliable way to inject into React controlled contenteditable elements\n    const success = document.execCommand('insertText', false, text);\n\n    if (!success) {\n        // Fallback for some browsers\n        editor.innerHTML += text;\n    }\n\n    // Dispatch input events to inform React/Quill of the change\n    editor.dispatchEvent(new Event('input', { bubbles: true }));\n    editor.dispatchEvent(new Event('change', { bubbles: true }));\n\n    // Auto-submit the comment using a retry loop\n    // We delay and retry to give LinkedIn's React app time to enable the button after the input event\n    let retries = 0;\n    const maxRetries = 5;\n\n    function trySubmit() {\n        if (!activePost) return;\n\n        const container = activePost.querySelector('.comments-comment-box') || activePost;\n        if (container) {\n            const submitBtn = container.querySelector('button.comments-comment-box__submit-button--cr');\n\n            // Wait for button to exist and verify it's not disabled\n            if (submitBtn) {\n                // Sometimes LinkedIn leaves the 'disabled' attribute even if visually ready\n                if (submitBtn.hasAttribute('disabled')) {\n                    submitBtn.removeAttribute('disabled');\n                }\n\n                submitBtn.click();\n                console.log(\"LinkedIn Face Tracker: Auto-submitted comment.\", retries);\n                return; // Success\n            }\n        }\n\n        retries++;\n        if (retries < maxRetries) {\n            setTimeout(trySubmit, 300); // Retry every 300ms\n        } else {\n            console.warn(\"LinkedIn Face Tracker: Submit button not found after retries.\");\n        }\n    }\n\n    setTimeout(trySubmit, 300);\n}\n\n// Start\ncreateTrackerIframe();\n"],"names":[],"sourceRoot":""}